<!DOCTYPE HTML>
<html>
  <head> <meta charset="utf-8"/>
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>Breakpoint: Cracking Phobos UUID</title>
    <link rel="stylesheet" type="text/css" href="../style/base.css"/>
    <link rel="stylesheet" type="text/css" href="../style/pygments.css"/>
    <link rel="stylesheet" type="text/css" href="../style/math.css"/>

    <link rel="icon" href="../image/favicon.ico" type="image/x-icon"/>

    <link rel="alternate" type="application/rss+xml" title="Breakpoint RSS" href="../rss.xml"/>
    <link rel="alternate" type="application/rss+xml" title="Stream of Consciousness RSS" href="../soc_rss.xml"/>
    <!--
        The RSS icon used in this page is derived from https://www.flaticon.com/free-icon/rss-feed-symbol_110
        made by https://www.flaticon.com/authors/freepik. Thank you for providing quality, open work.
    -->
  </head>
  <body>
    <header class="site-header">
      <div class="site-title">
        <div class="title-text">
          <h1>Breakpoint</h1>
          <h2>Stepping through security</h2>
        </div>
        <img src="../image/tomoko1.png"/>
      </div>
      <div class="wrap">

        <ul>
          <li>
              <a href="../index.html">Index</a>
              <a href="../rss.xml">
                  <img src="../image/rss.png" />
              </a>
          </li>
          <li><a href="https://github.com/cym13">Github</a></li>
          <li><a href="../soc.html">SoC</a>
              <a href="../soc_rss.xml">
                  <img src="../image/rss.png" />
              </a>
          </li>
          <li><a href="../about.html">About</a></li>
        </ul>
      </div>
    </header>

    <div class="content">
      <div class="section" id="cracking-phobos-uuid">
<h1>Cracking Phobos UUID</h1>
<div class="section" id="tl-dr-for-busy-people">
<h2>tl;dr for busy people</h2>
<ul class="simple">
<li><p>Contrary to other languages, D's current standard implementation of UUID4
isn't cryptographically secure and shouldn't be used to generate secrets
This is supported by the RFC which discourages people to use UUIDs for
secrets.</p></li>
<li><p>Of course lots of people, projects and frameworks use them to generate
secrets such as session cookies, password reset token and more because it's
easy, looks like it should work and does work in virtually any other
language.</p></li>
<li><p>Legitimately, people will ask &quot;OK, it's bad in theory, but how hard is it
in practice&quot;. I show in this article that it is possible to guess the next
UUID to be generated with a maximum of 8192 requests after having gathered
156 UUIDs: a very practical attack indeed compared to the original 2¹²⁸
possibilities.</p></li>
<li><p>This should be viewed as a call for action: Phobos must provide a secure
random number generator. It's too basic and important a component not to
provide it in a standard way.</p></li>
<li><p>If your project uses <strong>randomUUID()</strong>, make sure its value isn't supposed
to be secret. Otherwise change for a token built from cryptographically
secure randomness.</p></li>
</ul>
</div>
<div class="section" id="context">
<h2>Context</h2>
<p>Some time ago I had a nice chat with a library's maintainer about Random
Number Generation and their relation to security. It reminded me that the
topic is not obvious and I decided to have a look at the state of things in
<a class="reference external" href="https://dlang.org/">D</a> since that's become my topic of open-source
research these last years.</p>
<p>In particular, I knew that D's standard library, Phobos, does not currently
propose any standard way to get cryptographically secure random numbers. Not
too many projects use the default and insecure <strong>uniform()</strong> to generate
secrets such as session tokens. However I decided to have a look at UUIDs
since they are often for security purpose. And sure enough, many projects
that I will not list use insecure UUIDs.</p>
<p>The thing is, while they should not do so, I cannot fault them for thinking
that it is correct. In most languages UUIDs are generated from secure
randomness and are a reasonable way to generate secure secrets. But that is
not the case in D and this means that these projects are vulnerable.</p>
<p>In this post we'll see how we can predict future UUIDs from previous
ones. It's a bit of work certainly, but it's not that hard. Here's our
road map:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#identify">Identify</a>: see how random UUIDs are made in Phobos</p></li>
<li><p><a class="reference internal" href="#prepare">Prepare</a>: crack raw MT19937</p></li>
<li><p><a class="reference internal" href="#attack">Attack</a>: predict future UUIDs from past ones</p></li>
<li><p><a class="reference internal" href="#defend">Defend</a>: see how to fix this in your project and in Phobos</p></li>
</ul>
<p>This will be quite the long and technical post, but come along anyway, it is
sure to be interesting!</p>
<div class="section" id="a-word-on-randomness">
<h3>A word on randomness</h3>
<p>Before going further we need to be clear about what we mean by
cryptographically secure randomness and how it differs from regular
randomness.</p>
<p>Normal randomness is generally defined by only one assumption: to have no or
low bias. This means that if you were to generate lots of numbers, the number
of times you see each specific output should be evenly matched. This property
is sufficient for most applications, from a random dog name generator to
Monte-Carlo simulations.</p>
<p>However cryptographic randomness requires more though:</p>
<ul class="simple">
<li><p>It must not have any bias</p></li>
<li><p>It must not be possible to predict future outputs from old ones</p></li>
<li><p>It must not be possible to recover past outputs from current ones</p></li>
</ul>
<p>(The proper <a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator#Definitions">definition</a> is a bit stronger than this, but this will suffice
in the context of our article.)</p>
<p>If there's a bias, then I have information about what numbers are generated
without having to gather a single number. I do not think I need to explain
how predicting future numbers can be an issue for a system generating secrets
such as session tokens. The last item though can surprise, but consider this:
if it is possible to recover past outputs from current ones and you use these
random numbers for password reset tokens (for example), then I can ask a
reset of another user's password, then ask a reset of mine and determine what
the previous entry was, disclosing that user's password reset token.</p>
<p>Why aren't cryptographically secure pseudo-random number generators (CSPRNG)
used for everything if they're more secure? Because enforcing these
conditions also makes them much slower than conventional PRNGs and many
applications don't need these guarantees.</p>
<p>MT19937 is not a cryptographically secure pseudo-random number generator and
can't be used as one. It's not a matter of choosing the right seed, or
reseeding often (actually, reseeding often would be a benefit to us as we'll
see at the end). It has some bias (not much admittedly), but most importantly
it's both possible to predict the future and recover the past from just a few
outputs.</p>
<img alt="../image/chibi_cat_hurry_up.png" src="../image/chibi_cat_hurry_up.png" />
</div>
</div>
<div class="section" id="structure-of-a-uuid">
<span id="identify"></span><h2>Structure of a UUID</h2>
<div class="section" id="the-standard">
<h3>The standard</h3>
<p>Universally Unique Identifiers (UUID) are a category of identifiers defined
in <a class="reference external" href="https://tools.ietf.org/html/rfc4122.html">RFC 4122</a>. Their goal is, as
the name suggests, to provide a way got generate IDs that are guaranteed to
be different even across systems that can't communicate together. You've
probably seen them, they look like this:
<strong>0d3120f8-f209-43f2-949d-e70dcf228403</strong></p>
<p>There are different types of UUIDs, but the most common one is Type 4: random
UUIDs. These are described in section 4.4 of the RFC as such:</p>
<ul class="simple">
<li><p>bits 6 and 7 must be set to 0 and 1</p></li>
<li><p>bits 12 to 15 must be set to the UUID version number: 4 in this case (0100)</p></li>
<li><p>all 122 other bits must be set to random values</p></li>
</ul>
<p>In practice, libraries generally choose 4 32-bit random numbers, concatenate
them and then change bits 6,7 and 12 to 15. This means that some information
about these random numbers is lost in the process, we don't get a clean PRNG
output.</p>
<p>Note that the RFC does not require the use of cryptographically secure random
numbers, but it does warn against using UUIDs for sensitive values if normal
randomness is used.</p>
</div>
<div class="section" id="phobos-implementation">
<h3>Phobos implementation</h3>
<p>Phobos' <strong>randomUUID()</strong> follows these lines perfectly, using non-secure
randomness.</p>
<pre class="code java literal-block"><code><span class="n">UUID</span> <span class="nf">randomUUID</span><span class="p">(</span><span class="n">RNG</span><span class="p">)(</span><span class="n">ref</span> <span class="n">RNG</span> <span class="n">randomGen</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">isInputRange</span><span class="o">!</span><span class="n">RNG</span> <span class="o">&amp;&amp;</span> <span class="n">isIntegral</span><span class="o">!</span><span class="p">(</span><span class="n">ElementType</span><span class="o">!</span><span class="n">RNG</span><span class="p">))</span>
<span class="p">{</span>
    <span class="kn">import</span> <span class="nn">std.random</span> <span class="p">:</span> <span class="n">isUniformRNG</span><span class="p">;</span>
    <span class="kd">static</span> <span class="nf">assert</span><span class="p">(</span><span class="n">isUniformRNG</span><span class="o">!</span><span class="n">RNG</span><span class="p">,</span> <span class="s">&quot;randomGen must be a uniform RNG&quot;</span><span class="p">);</span>

    <span class="n">alias</span> <span class="n">E</span> <span class="o">=</span> <span class="n">ElementEncodingType</span><span class="o">!</span><span class="n">RNG</span><span class="p">;</span>
    <span class="kd">enum</span> <span class="n">size_t</span> <span class="n">elemSize</span> <span class="o">=</span> <span class="n">E</span><span class="p">.</span><span class="na">sizeof</span><span class="p">;</span>
    <span class="kd">static</span> <span class="nf">assert</span><span class="p">(</span><span class="n">elemSize</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">);</span>
    <span class="kd">static</span> <span class="nf">assert</span><span class="p">(</span><span class="mi">16</span> <span class="o">%</span> <span class="n">elemSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">UUID</span> <span class="n">u</span><span class="p">;</span>
    <span class="n">foreach</span> <span class="p">(</span><span class="n">ref</span> <span class="n">E</span> <span class="n">e</span> <span class="p">;</span> <span class="n">u</span><span class="p">.</span><span class="na">asArrayOf</span><span class="o">!</span><span class="n">E</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">randomGen</span><span class="p">.</span><span class="na">front</span><span class="p">;</span>
        <span class="n">randomGen</span><span class="p">.</span><span class="na">popFront</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//set variant
</span>    <span class="c1">//must be 0b10xxxxxx
</span>    <span class="n">u</span><span class="p">.</span><span class="na">data</span><span class="o">[</span><span class="mi">8</span><span class="o">]</span> <span class="o">&amp;=</span> <span class="mb">0b10111111</span><span class="p">;</span>
    <span class="n">u</span><span class="p">.</span><span class="na">data</span><span class="o">[</span><span class="mi">8</span><span class="o">]</span> <span class="o">|=</span> <span class="mb">0b10000000</span><span class="p">;</span>

    <span class="c1">//set version
</span>    <span class="c1">//must be 0b0100xxxx
</span>    <span class="n">u</span><span class="p">.</span><span class="na">data</span><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="o">&amp;=</span> <span class="mb">0b01001111</span><span class="p">;</span>
    <span class="n">u</span><span class="p">.</span><span class="na">data</span><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="o">|=</span> <span class="mb">0b01000000</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<p>It generates 4 32-bit uint values using the default random number generator
of std.random: MT19937. If that PRNG's state is too small, it falls back on
Xorshift192 (<a class="reference external" href="https://github.com/dlang/phobos/blob/v2.093.0/std/uuid.d#L1200">code here</a>).</p>
<p>So our main target is Mersenne Twister 19937, possibly the most common PRNG
in use.</p>
<img alt="../image/chibi_cat_me_want.png" src="../image/chibi_cat_me_want.png" />
</div>
</div>
<div class="section" id="cracking-mt19937">
<span id="prepare"></span><h2>Cracking MT19937</h2>
<div class="section" id="previous-work">
<h3>Previous work</h3>
<p>So, <a class="reference external" href="https://en.wikipedia.org/wiki/Mersenne_Twister">MT19937</a> is
well-known, used a lot, and insecure. Surely other people have written about
cracking it in the past?</p>
<p>Indeed, there is a profusion of <a class="reference external" href="https://jazzy.id.au/2010/09/22/cracking_random_number_generators_part_3.html">articles</a>
but the most interesting one was definitely <a class="reference external" href="https://www.ambionics.io/blog/php-mt-rand-prediction">this article</a> by Ambionics that
does something different.</p>
<p>The basic strategy we see in these articles is to recover the internal
624-byte state of the Mersenne Twister by collecting 624 values. From there
it is possible to predict any future value. Of course this isn't immediately
an option for our larger project since some bits are missing from UUIDs due
to how they are built, but it is an important cornerstone.</p>
<p>The Ambionics strategy is very interesting also: they show that since each
output value depends only on two state values, it is possible to recover the
previous value with only two outputs. From there they rebuild the complete
seed by inverting its process. Good stuff. We will not get to use it but it
is definitely worth a read.</p>
<p>In the end all Mersenne Twisters are a bit different so we need to tailor the
approach for Phobos, but we will use two values to predict the next one.</p>
</div>
<div class="section" id="how-mt19937-works">
<h3>How MT19937 works</h3>
<p>MT19337's internal state is an array of 624 32-bit integers. That array is
seeded at initialization but we will not discuss seeding in this article. For
all intent and purposes, we start with an array of 624 random integers.</p>
<p>Once seeded, two mechanisms are at play. One outputs a number after
scrambling it (in blue in the figure) while the other updates the next entry
by combining three elements of the state array: the <em>index</em>, the <em>next</em> and
the <em>conjugate</em> (naming is hard). This process is in orange in the figure.</p>
<img alt="../image/mt19937_1.png" src="../image/mt19937_1.png" style="width: 70%;" />
<p>The actual values presented are mostly specific to Phobos' implementation,
but let's note the most important ones:</p>
<pre class="literal-block">n = 624    a = 0x9908b0df   c = 0xefc60000
m = 397    b = 0x9d2c5680</pre>
<p>One thing isn't apparent in this diagram, and it is how <em>next</em> and <em>index</em>
are combined to produce <em>y</em>. <em>y</em> is composed of the most significant bit of
<em>index</em> and all bits from <em>next</em> except its most significant one.</p>
<p>Each time a new number is outputted, both of these processes go one step to
the left, walking the state array in reverse order. After <em>n</em> iterations it
loops back to the end of the array.</p>
<p>You can read Phobos's implementation <a class="reference external" href="https://github.com/dlang/phobos/blob/master/std/random.d#L955">here</a> but note
that, in order to improve caching performances, both the blue and orange
processes are interweaved.</p>
<p>And with this we are ready to crack normal MT19937!</p>
</div>
<div class="section" id="reversing-the-scrambling">
<h3>Reversing the scrambling</h3>
<p>MT19937 is entirely defined by its internal state. If we can identify all its
624 components then we can just set the state of our own MT19937 PRNG with
these values and it'll output the same numbers. Now, given one output, if we
are able to reverse the scrambling (blue process) then we directly obtain the
corresponding state value. And if we're able to do it once, we can do it for
624 consecutive outputs and have a full internal state. The key part is that
we never need to worry about the updating (orange) process in that scenario.</p>
<img alt="../image/mt19937_2.png" src="../image/mt19937_2.png" style="width: 70%;" />
<p>In code, this gives:</p>
<pre class="code java literal-block"><code><span class="n">uint</span> <span class="nf">scramble</span><span class="p">(</span><span class="n">uint</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">immutable</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x9d2c5680</span><span class="p">;</span>
    <span class="n">immutable</span> <span class="n">c</span> <span class="o">=</span> <span class="mh">0xefc60000</span><span class="p">;</span>

    <span class="n">z</span> <span class="o">^=</span>  <span class="n">z</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">^=</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;&lt;</span>  <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">^=</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">^=</span> <span class="p">(</span><span class="n">z</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<p>Sliding things left and right... Let's just slide the other way around (with
a twist to account for overlaps.</p>
<pre class="code java literal-block"><code><span class="n">uint</span> <span class="nf">unscramble</span><span class="p">(</span><span class="n">uint</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">immutable</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x9d2c5680</span><span class="p">;</span>
    <span class="n">immutable</span> <span class="n">c</span> <span class="o">=</span> <span class="mh">0xefc60000</span><span class="p">;</span>

    <span class="n">z</span> <span class="o">^=</span> <span class="p">(</span><span class="n">z</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">);</span>
    <span class="n">z</span> <span class="o">^=</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">undoLshiftXorMask</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// The twist
</span>    <span class="n">z</span> <span class="o">^=</span> <span class="n">z</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">;</span>
    <span class="n">z</span> <span class="o">^=</span> <span class="n">z</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">uint</span> <span class="nf">undoLshiftXorMask</span><span class="p">(</span><span class="n">uint</span> <span class="n">v</span><span class="p">,</span> <span class="n">uint</span> <span class="n">shift</span><span class="p">,</span> <span class="n">uint</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint</span> <span class="nf">bits</span><span class="p">(</span><span class="n">uint</span> <span class="n">v</span><span class="p">,</span> <span class="n">uint</span> <span class="n">start</span><span class="p">,</span> <span class="n">uint</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">foreach</span> <span class="p">(</span><span class="n">i</span> <span class="p">;</span> <span class="n">iota</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">shift</span><span class="p">))</span>
        <span class="n">v</span> <span class="o">^=</span> <span class="p">(</span><span class="n">bits</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">shift</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bits</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shift</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">unittest</span> <span class="p">{</span>
    <span class="n">uint</span> <span class="n">z</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="n">unscramble</span><span class="p">(</span><span class="n">scramble</span><span class="p">(</span><span class="n">z</span><span class="p">)));</span>
<span class="p">}</span></code></pre>
<p>And just like that, the first hurdle is behind us. Easy. All we need to do to
predict all future numbers is to collect 624 consecutive numbers, unscramble
them and use them to seed our own MersenneTwisterEngine. But that is not our
goal, so let's move on.</p>
<img alt="../image/chibi_cat_disillusioned.png" src="../image/chibi_cat_disillusioned.png" />
</div>
</div>
<div class="section" id="predicting-one-number">
<h2>Predicting one number</h2>
<p>This is an intermediate step toward our goal. We saw that we have the
elements to crack MT19937 if we get 624 consecutive outputs, but when we get
to UUIDs we won't have that luxury. Remember that each UUID is made of 4
outputs (128 bits) of which 6 bits are missing. If we tried to bruteforce
these 6 bits missing for every 4 outputs we would have to bruteforce 936
bits, which is far outside the realm of possibility.</p>
<p>However, remember that updating a value is done using only 3 base values
so if we know the right 3 state values we can predict one next state.</p>
<img alt="../image/mt19937_3.png" src="../image/mt19937_3.png" style="width: 70%;" />
<p>That part is not actually difficult since we just need to follow exactly what
the algorithm normally does. We just need to unscramble/rescramble our raw
output value.</p>
<pre class="code java literal-block"><code><span class="n">uint</span> <span class="nf">predictNumber</span><span class="p">(</span><span class="n">uint</span> <span class="n">index</span><span class="p">,</span> <span class="n">uint</span> <span class="n">next</span><span class="p">,</span> <span class="n">uint</span> <span class="n">conj</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">immutable</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">624</span><span class="p">;</span>
    <span class="n">immutable</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">397</span><span class="p">;</span>
    <span class="n">immutable</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x9908b0df</span><span class="p">;</span>

    <span class="n">uint</span> <span class="n">lowerMask</span> <span class="o">=</span> <span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="mi">1</span><span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// All bits but the MSB
</span>    <span class="n">uint</span> <span class="n">upperMask</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">lowerMask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">uint</span><span class="p">.</span><span class="na">max</span><span class="p">;</span>   <span class="c1">// Most Significant Bit
</span>
    <span class="n">uint</span> <span class="n">q</span> <span class="o">=</span> <span class="n">unscramble</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">upperMask</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">p</span> <span class="o">=</span> <span class="n">unscramble</span><span class="p">(</span><span class="n">next</span><span class="p">)</span>  <span class="o">&amp;</span> <span class="n">lowerMask</span><span class="p">;</span>

    <span class="n">uint</span> <span class="n">y</span> <span class="o">=</span> <span class="n">q</span> <span class="o">|</span> <span class="n">p</span><span class="p">;</span>

    <span class="n">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">^=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">unscramble</span><span class="p">(</span><span class="n">conj</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">scramble</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">unittest</span> <span class="p">{</span>
    <span class="kn">import</span> <span class="nn">std.random</span><span class="p">;</span>

    <span class="n">auto</span> <span class="n">prng</span> <span class="o">=</span> <span class="n">Mt19937</span><span class="p">(</span><span class="n">unpredictableSeed</span><span class="p">());</span>

    <span class="n">immutable</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">624</span><span class="p">;</span>
    <span class="n">immutable</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">397</span><span class="p">;</span>
    <span class="n">immutable</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x9908b0df</span><span class="p">;</span>

    <span class="n">uint</span><span class="o">[]</span> <span class="n">rawOutput</span> <span class="o">=</span> <span class="n">prng</span><span class="p">.</span><span class="na">take</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="mi">2</span><span class="p">).</span><span class="na">array</span><span class="p">;</span>

    <span class="n">uint</span> <span class="n">index</span>  <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">target</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>

    <span class="n">auto</span> <span class="n">prediction</span> <span class="o">=</span> <span class="n">predictNumber</span><span class="p">(</span><span class="n">rawOutput</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">,</span>      <span class="c1">// index
</span>                                    <span class="n">rawOutput</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">,</span>    <span class="c1">// next
</span>                                    <span class="n">rawOutput</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">397</span><span class="o">]</span><span class="p">);</span> <span class="c1">// conjugate
</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">rawOutput</span><span class="o">[</span><span class="n">target</span><span class="o">]</span> <span class="o">==</span> <span class="n">prediction</span><span class="p">);</span>
<span class="p">}</span></code></pre>
<p>Alright, so we can read only 3 values which allows us to predict the next
value &quot;index&quot; will have, so 624 outputs later. Now, let's move to the meat of
the challenge: can we still do this efficiently when we start removing bits
due to how UUIDs are formatted?</p>
<img alt="../image/chibi_cat_catching_prey.png" src="../image/chibi_cat_catching_prey.png" />
</div>
<div class="section" id="cracking-mt19937-uuids">
<span id="attack"></span><h2>Cracking MT19937 UUIDs</h2>
<p>The main issue with UUIDs come, of course, from the fact that some
information is missing. There is nothing we can do to magically summon up
these missing bits, but if few enough are missing we can enumerate all
possibilities. This will give us a list of candidate UUIDs to try against the
vulnerable system.</p>
<p>Each UUID is made of 4 integers, so we will need to work on each of these 4
parts independently. They present different situations so let's give each
UUID part its own name.</p>
<img alt="../image/uuid_parts.png" src="../image/uuid_parts.png" style="width: 80%;" />
<p>Now let's say that we have a UUID. <em>Index</em> is a P0 and we want to predict the
next value at that index (so in 624 outputs). Our <em>next</em> is a P1 naturally,
and our <em>conjugate</em> is 397 places further than the <em>index</em>. Since 397 % 4 = 1
our <em>conjugate</em> will also be a P1. Since 4 bits are missing in each P1 there is
a total of 8 unknown bits to predict that future integer.</p>
<img alt="../image/uuid_parts_p0.png" src="../image/uuid_parts_p0.png" style="width: 60%;" />
<p>We can reason in the same way for P1</p>
<img alt="../image/uuid_parts_p1.png" src="../image/uuid_parts_p1.png" style="width: 60%;" />
<p>There 2 bits are missing from both the <em>next</em> and <em>conjugate</em>. Since we
don't know the correct value of the previous part we also don't know its most
significant bit so we need to bruteforce it. It should be possible to find it
for each previously-computed candidate but we didn't spend any time on this.</p>
<p>There are 5 missing bits for P1 bringing our total to 13 missing bits.</p>
<p>Fortunately, even though two bits are overwritten in P2, its most significant
bit remains unchanged, so we have everything we need to compute its future
value. There is no missing bit here.</p>
<img alt="../image/uuid_parts_p2.png" src="../image/uuid_parts_p2.png" style="width: 60%;" />
<p>And finally P3 benefits from similarly great conditions with no missing bit.</p>
<img alt="../image/uuid_parts_p3.png" src="../image/uuid_parts_p3.png" style="width: 60%;" />
<p>Finally, our grand total is 13 missing bits that we will have to bruteforce
within 4 integers. Once we identified which bits needed to be bruteforced
this is an easy task. This will provide a list of 8192 candidates.</p>
<blockquote>
<p><em>Debugging tip: I was actually a bit thrown off by endianness here and
for a time couldn't find where my missing bits were. In that case
remember that even though some bits are overwritten, you still have a
chance that they weren't changed and the UUID is still valid: a
collision. This means that, by running statistical tests as you tweak
your values you can measure how many bits you have right by how many
times collisions occurred. This proved very very useful in this case. Of
course visualizing data as bits is also a good idea.</em></p>
</blockquote>
<p>And so finally here is the code allowing us to predict UUIDs from a list of
UUID outputs.</p>
<pre class="code java literal-block"><code><span class="n">auto</span> <span class="nf">predictUuid</span><span class="p">(</span><span class="n">UUID</span><span class="o">[]</span> <span class="n">uuidLst</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">uuidIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="n">uuidLst</span><span class="p">.</span><span class="na">map</span><span class="o">!</span><span class="n">uuidToUints</span><span class="p">.</span><span class="na">join</span><span class="p">;</span>

    <span class="n">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">uuidIndex</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

    <span class="n">uint</span><span class="o">[]</span> <span class="n">part0</span><span class="p">;</span>
    <span class="n">foreach</span> <span class="p">(</span><span class="n">mask1</span> <span class="p">;</span> <span class="mf">0..16</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uint</span> <span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">397</span><span class="o">]</span><span class="p">;</span>

        <span class="n">c</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">15</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="o">-</span><span class="mi">12</span><span class="p">);</span>
        <span class="n">c</span> <span class="o">|=</span> <span class="n">mask1</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="o">-</span><span class="mi">12</span><span class="p">;</span>

        <span class="n">foreach</span> <span class="p">(</span><span class="n">mask2</span> <span class="p">;</span> <span class="mf">0..16</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">uint</span> <span class="n">n</span>  <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>

            <span class="n">n</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">15</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="o">-</span><span class="mi">12</span><span class="p">);</span>
            <span class="n">n</span> <span class="o">|=</span> <span class="n">mask2</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="o">-</span><span class="mi">12</span><span class="p">;</span>

            <span class="n">part0</span> <span class="o">~=</span> <span class="n">predictNumber</span><span class="p">(</span><span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">uint</span><span class="o">[]</span> <span class="n">part1</span><span class="p">;</span>
    <span class="n">foreach</span> <span class="p">(</span><span class="n">mask1</span> <span class="p">;</span> <span class="mf">0..4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uint</span> <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>

        <span class="n">n</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
        <span class="n">n</span> <span class="o">|=</span> <span class="n">mask1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>

        <span class="n">foreach</span> <span class="p">(</span><span class="n">mask2</span> <span class="p">;</span> <span class="mf">0..4</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">uint</span> <span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">397</span><span class="o">]</span><span class="p">;</span>

            <span class="n">c</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
            <span class="n">c</span> <span class="o">|=</span> <span class="n">mask2</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>

            <span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
            <span class="n">part1</span> <span class="o">~=</span> <span class="n">predictNumber</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

            <span class="n">i</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">;</span>
            <span class="n">part1</span> <span class="o">~=</span> <span class="n">predictNumber</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">uint</span> <span class="n">part2</span> <span class="o">=</span> <span class="n">predictNumber</span><span class="p">(</span><span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">2</span><span class="o">]</span><span class="p">,</span>
                               <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">,</span>
                               <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="mi">397</span><span class="o">]</span><span class="p">);</span>

    <span class="n">uint</span> <span class="n">part3</span> <span class="o">=</span> <span class="n">predictNumber</span><span class="p">(</span><span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">3</span><span class="o">]</span><span class="p">,</span>
                               <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">,</span>
                               <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">397</span><span class="o">]</span><span class="p">);</span>

    <span class="n">UUID</span><span class="o">[]</span> <span class="n">candidates</span><span class="p">;</span>
    <span class="n">foreach</span> <span class="p">(</span><span class="n">p0</span> <span class="p">;</span> <span class="n">part0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">foreach</span> <span class="p">(</span><span class="n">p1</span> <span class="p">;</span> <span class="n">part1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ubyte</span><span class="o">[</span><span class="mi">16</span><span class="o">]</span> <span class="n">candidate</span><span class="p">;</span>
            <span class="n">candidate</span><span class="o">[</span> <span class="mi">0</span> <span class="p">..</span>  <span class="mi">4</span><span class="o">]</span> <span class="o">=</span> <span class="n">nativeToLittleEndian</span><span class="p">(</span><span class="n">p0</span><span class="p">);</span>
            <span class="n">candidate</span><span class="o">[</span> <span class="mi">4</span> <span class="p">..</span>  <span class="mi">8</span><span class="o">]</span> <span class="o">=</span> <span class="n">nativeToLittleEndian</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
            <span class="n">candidate</span><span class="o">[</span> <span class="mi">8</span> <span class="p">..</span> <span class="mi">12</span><span class="o">]</span> <span class="o">=</span> <span class="n">nativeToLittleEndian</span><span class="p">(</span><span class="n">part2</span><span class="p">);</span>
            <span class="n">candidate</span><span class="o">[</span><span class="mi">12</span> <span class="p">..</span> <span class="mi">16</span><span class="o">]</span> <span class="o">=</span> <span class="n">nativeToLittleEndian</span><span class="p">(</span><span class="n">part3</span><span class="p">);</span>

            <span class="n">candidate</span><span class="o">[</span><span class="mi">8</span><span class="o">]</span> <span class="o">&amp;=</span> <span class="mb">0b10111111</span><span class="p">;</span>
            <span class="n">candidate</span><span class="o">[</span><span class="mi">8</span><span class="o">]</span> <span class="o">|=</span> <span class="mb">0b10000000</span><span class="p">;</span>

            <span class="n">candidate</span><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="o">&amp;=</span> <span class="mb">0b01001111</span><span class="p">;</span>
            <span class="n">candidate</span><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="o">|=</span> <span class="mb">0b01000000</span><span class="p">;</span>

            <span class="n">candidates</span> <span class="o">~=</span> <span class="n">UUID</span><span class="p">(</span><span class="n">candidate</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">candidates</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<p>I considered demonstrating this on a real project, finding one is easy
enough, but that would be a disservice to that project. I do not wish to draw
attention and possibly malicious actors to any particular project. However I
did test that attack in practice as such:</p>
<ul class="simple">
<li><p>Identify a website who's session cookies are generated from Phobos' UUID</p></li>
<li><p>Create a legitimate account</p></li>
<li><p>Login/logout 156 times to build a list of consecutive UUIDs
(consecutiveness can be difficult if the website is busy but is practical
outside peak hours)</p></li>
<li><p>You can now build a list of 8192 candidate UUID and know that the next
session token generated will be part of that list</p></li>
<li><p>At that point I logged in with another account</p></li>
<li><p>Try all candidates, one of them will work. 8000 requests can be done in a
matter of seconds so it is definitely a practical attack.</p></li>
</ul>
<p>A similar strategy can be applied for filenames in symlink attacks, password
reset tokens (the best since you can ask to reset another account, there is
no need to wait), API endpoints that are supposed to be unguessable etc.</p>
<img alt="../image/chibi_cat_computer_savy.png" src="../image/chibi_cat_computer_savy.png" />
</div>
<div class="section" id="mitigations">
<span id="defend"></span><h2>Mitigations</h2>
<div class="section" id="proper-solution-use-the-csprng-from-your-system">
<h3>Proper solution: use the CSPRNG from your system</h3>
<p>Secrets must be generated using cryptographic randomness. On Windows this
means CryptGenRandom, on Linux getrandom() or /dev/urandom, on unix
/dev/random. There are libraries that implement a cross-platform wrapper
correctly such as libsodium (see <a class="reference external" href="https://code.dlang.org/packages/sodium">sodium</a> for D bindings).</p>
<p>As a project manager you should consider introducing such a dependency since
there's no substitute for a good CSPRNG and no CSPRNG can be properly seeded
without relying on the system.</p>
<p>However the best way to solve this particular issue would be for Phobos to
provide this interface to the system CSPRNG directly. People take the path of
least resistance, that's a fact that we have to work with. At the moment it
is significantly harder for people to use secure randomness instead of just
going for std.random.uniform(), often &quot;temporarily&quot;. If std.uuid is to
change, and it should, it must rely on the system CSPRNG and not something
else.</p>
<p>I know that there is some reluctance to introduce anything related to
cryptography in the standard library, but here we are not talking about
reimplementing an algorithm. It is a case where not acting is provably
causing more damage than providing a standard solution. Especially at the web
era, access to cryptographic randomness is a must.</p>
</div>
<div class="section" id="improper-solution-let-s-use-the-cpu-s-csprng">
<h3>Improper solution: let's use the CPU's CSPRNG</h3>
<p><em>The CPU generally embeds a CSPRNG nowadays no? Why not use this instead of
dealing with OS specific resources?</em></p>
<p>There are several reasons. For example the system has access to more
entropy and uses the CPU as a source of entropy if available so the system
CSPRNG is guaranteed to be at least as good as the CPU and often better.</p>
<p>Furthermore there have been cases even recently of flaws in CPU CSPRNG.
That's even without considering the fact that it is closed-source which is
never a good thing for security.</p>
<p>But the main reason is more simple: what if the CPU doesn't provide a CSPRNG?
Not all CPUs do, far from it, so what are you supposed to do? Fallback
silently on a method that we know causes issues? That would be giving a false
sense of security even more harmful than what is currently done.</p>
</div>
<div class="section" id="improper-solution-let-s-write-our-own-csprng">
<h3>Improper solution: let's write our own CSPRNG</h3>
<p><em>Still, having to deal with platform-specific code is a pain. Can't I just
write my own CSPRNG instead of depending on the system?</em></p>
<p>Nobody should roll their own crypto and expect it to be usable in production.
But let's suppose that you wrote this difficult and critical component
correctly: how are you providing it with entropy?</p>
<p>The only sane source is to draw from the system's CSPRNG, so you're still
not better than if you used it directly, you just added another layer of
bugs.</p>
<p>You might try to collect entropy elsewhere, but you're bound to have less
access to it than the system, and any such collection involves platform
specific code anyway. There's nothing to be gained from this.</p>
</div>
<div class="section" id="improper-solution-let-s-reseed-often">
<h3>Improper solution: let's reseed often</h3>
<p><em>This attack requires you to read many values. I just need to reseed more
often so that the value you're predicting never comes out.</em></p>
<p>There is this common misconception that the issue with non-cryptographic PRNG
can be solved by reseeding often. It's true that if you reseed after less
than 624 outputs the attack we outlined is not possible. However it opens the
way to several attacks that are much easier that what we did.</p>
<p>First of all reseeding is only as good as the seed's randomness. You
therefore fall into the same traps as we discussed earlier: if you want it to
be unpredictable you need cryptographic randomness, and therefore you need to
draw from the system's CSPRNG anyway.</p>
<p>But there's a more pernicious effect. The way seeding happens is that the
seed is scrambled repeatedly to provide each of the 624 internal states of
MT19937. So instead of attacking the scrambling of MT19937 and its hundreds
of internal states, we only need to attack the scrambling of the seeding
method, which is much easier to reverse. <a class="reference external" href="https://www.ambionics.io/blog/php-mt-rand-prediction">This article by ambionics</a> uses this strategy
to determine the entire internal state by reading only 2 values.</p>
<p>A non-cryptographic PRNG is not suited for cryptographic tasks. It's a fool's
errand to try to twist it into being secure when it is neither its purpose
nor its strength.</p>
<img alt="../image/chibi_cat_sleeping.png" src="../image/chibi_cat_sleeping.png" />
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>As we have seen, it is fairly easy to predict Phobos UUIDs. While the RFC
does not require UUIDs to be unpredictable, practice shows that many people
expect them to be cryptographically secure. This causes many security issues
in many projects.</p>
<p>I strongly recommend that Phobos adds a proper standard interface to the
system's CSPRNG. That's the only way to solve not only the core of the UUID
issue but also many similar issues that stem from the fact that it is
currently much easier to use a regular PRNG than a CSPRNG, even when one is
absolutely required.</p>
<hr class="docutils" />
<div class="section" id="image-sources">
<h3>Image sources</h3>
<p>All schemas were made by me and are provided under the <a class="reference external" href="https://creativecommons.org/licenses/by/3.0/">creative commons
3.0 unported license</a> like
any other original content on this blog.</p>
<p>All cat pictures in this article come from
<a class="reference external" href="https://chatsticker.com/sticker/tibi-neko-sticker-no-language-ver-1">https://chatsticker.com/sticker/tibi-neko-sticker-no-language-ver-1</a>.</p>
</div>
</div>
</div>
    </div>
    <footer "class"="site-footer">
      <div "class"="publication_date">
        First published: Mon, 24 Aug 2020 10:08:40 +0200
      </div>
    </footer>
  </body>
</html>
